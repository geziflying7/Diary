每天进步一点点，未来前进一大步：
---------------------------------------------------------------------------------
生活中总能出现一些事情让自己意想不到，这不，大姨妈，总在不经意想起的时候，来到你的身边。
幸好早有准备，不至于太尴尬。开心做事，开心做人，每一个细胞都是快乐的跳动着。
---------------------------------------------------------------------------------
上午：fore medierm/morning
    开始：
    1、egret中，在shape图形上，加载一些文本对象，需要将shape对象强制转换成一种对象容器；
      或者是将文本对象添加到图形相对应的坐标位置，visible设置为true;
      scrollRect：它是一个显示对象的属性
      显示对象的 scrollRect = new egret.rectAngle(x,y,widh,height);
    2、使用位图缓存：
      对显示对象使用位图缓存，会创建一个独立的位图数据，位图缓存可以更快的现实较为复杂的矢量图形，或者较深层次嵌套列表
      --复杂的背景图像：包含矢量数据的详细的复杂背景图像
      --文本滚动文字：在滚动文本字段中显示大量的文本；
                可以将文本放置在您设置为可滚动的具有滚动框（使用 scrollRect 属性）的显示对象中。这可以使指定的实例进行快速像素滚动。
                当用户滚动显示对象实例时，Egret 会通过将滚动的像素向上移来生成新的看得见的区域，而不是重新生成整个文本字段；
      使用位图缓存：mySprite.cacheAsBitmap = true;
      使用位图后，你可能会注意到：现实对象的坐标会自动跟整个坐标对齐；
      即便是将 cacheAsBitmap 设置为 true，如果出现内存不足或平台对画布创建数量有限制，将不创建位图缓存：
    3、应用混合模式
                混合模式市将以和图像的像素值，和另一个图像的像素值进行混合，异变产生一个在实际舞台上显示的一个新的像素值。
                这个像素值被其他图像的像素值进行使用，一边在其他地方显示同一个像素值。   
     每一个显示对象，都有一个blendMode属性，可以将其设置为混合模式之一。
                以下是在blendMode类中定义的常量。此外，还可以使用string值，这些值是常量的实际值。
                mySprite.blendMode = egret.BlendMode.NORMAL;//用于指定混合图像的像素值覆盖整个基本图像的像素值
                mySprite.blendMode = "normal";
                mySprite.blendMode = egret.BelndMode.ADD;//通常用于创建两个图像之间的动画变亮的模糊效果
                mySprite.blendMode = "add";
                mySprite.blendMode = egret.BlendMode.erase;//根据显示对象的alpha值擦除背景。alpha值不为0的区域将被擦除
                mySprite.blendMode = "erase";
    4、旋转和遮罩显示对象
       旋转显示对象：使用rotation属性可以旋转显示对象；
              根据此值可以看出是否需要旋转此显示对象，如果需要旋转这个显示对象，那么将这个值设置成0-360之间的数字，表示显示对象旋转的角度。
                //把显示对象旋转45度
                mySprite.rotation = 45;
       遮罩显示对象：mask,通过将一个显示对象用作遮罩来创建一个孔洞，通过孔洞使另一个显示对象的内容可见。
              定义遮罩：mySprite.mask = maskSprite;
              将上面的属性设置为null，可以删除遮罩；
              用作遮罩的显示对象可设置动画、动态调整大小。遮罩显示对象不一定需要添加到显示列表中。但是，如果希望在缩放舞台时也缩放遮罩对象，或者如果希望支持用户与遮罩对象的交互（如调整大小），则必须将遮罩对象添加到显示列表中。
              -------通过将 mask 属性设置为 null 可以删除遮罩：mySprite.mask = null;
            ---------注意：不能使用一个遮罩对象来遮罩另一个遮罩对象---------------
            当 mask 为 Rectangle 时，如果修改过 mask 的值，必须对显示对象重新赋值 mask。
            当 mask 为 DisplayObject 时，不需要重复赋值 mask，但是 mask 必须是显示列表里元素。
   
   
   
   下午：post medierm/afternoon
       显示容器：
       1、显示容器的概念与实现
                显示容器：所有的容器全部继承自DisplayObjectContainer类，DisplaiObjectContainer继承自DisplayObject/
                        in a word,egret中所有的容器都是继承自DisplayObject;
                    DisplayObjectContainer中封装了一些列表中常用的功能:
                    主要分为四大类：
                            添加、删除子对象；
                            访问子对象；
                            检测子对象；
                            设置叠放次序；
                其他容器：Sprite轻量级显示容器
                        在Egret中，我们还有一个其他的容器：Sprite。
                        如果你查看Sprite类的内容,你会发现，Sprite仅仅是继承 DisplayObjectContainer；
                        同时添加了一个Graphics功能；
                        关于Graphics功能我们会在矢量绘图部分进行详细讲解。
                自定义容器：
                       想要编写一个自定义容器非常简单，编写一个类，继承自DisplayObjectContainer即可；
                       想要实现相关的graphics功能，只需要继承Sprite即可；
       
       2、添加与删除显示对象
                建立显示对象、渲染显示对象：这是两个过程；
                建立显示对象后，显示对象会处于内存中，不会参与渲染过程；
                只有把显示对象放到显示列表中，之后，显示对象才会参与渲染过程；
                如果想把某个显示对象的渲染删除，只需要将显示对象从显示列表中删除即可；
                层级结构：---舞台---文档类---显示对象---
                
             删除显示对象：this.removeChild(spr);
             
             显示对象操作的注意点:
                        1、显示对象独立于显示列表：
                           当用户将显示对象从显示列表中移除后，这些状态依然存在;
                           将一个显示对象移除显示列表后，该对象并非在内存中被销毁;
                           我们只是不让显示对象参与渲染而已;
                        2、相对坐标系：
                           显示对象的坐标系是相对坐标系，而非绝对坐标系；相对于父级对象的坐标
                           创建图形，添加在不同的容器中显示，相对于此时的父级对象的坐标；
                        3、多次添加显示对象到显示列表：
                           同一个显示对象无论被代码加入显示列表多少次，在屏幕上只绘制一次；
                           如果一个显示对象A被添加到了B这个容器中，然后A又被添加到了C容器中；
                           那么在第二次执行 C.addChild(A) 的时候，【A自动的从B容器中被删除】，然后添加到C容器中；
                        4、删除操作中的注意点：
                           当我们想要删除一个显示对象的时候需要执行的操作：--------容器对象.removeChild( 显示对象 );
                           但执行这个删除操作，我们的“显示对象”必须拥有父级。换句话说，被删除的显示对象必须存在于显示列表当中。
                           如果当前删除显示对象不在显示列表之中，那么在JavaScript控制台中你将看见报错信息：Uncaught Error: [Fatal]child未被addChild到该parent:
                           避免这种问题的处理方法非常简单，就是当你每次removeChild之前，你都对即将要被删除的显示对象做一次判断，
                           判断它是否拥有父级。判断的代码如下：
                           if(spr.parent){
                                spr.parent.removeChild(spr);
                           }
                           
        3、深度管理：
            每一个容器都有自己的深度管理功能。
            z-次序：
                每一个显示对象在其父级的容器中都应该拥有一个属于自己的深度值，而且这个值相对于同级显示对象应该是唯一的；
                这个深度值实际上就是一个显示对象的叠放次序。我们也称之为 “z-次序；
            容器.numChildren:获取当前容器的子对象数量 ；
            
            
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
  
